#!/usr/bin/env python3

import mimetypes
import os

from PIL import Image

from tcam import Tcam, decor


def to_bin(text: str):
    return "".join([format(ord(char), "08b") for char in text])


def encode(img_path, text, save_name, delimiter: str = "11111110"):

    global DONE
    message = to_bin(text) + delimiter
    image = Image.open(img_path)
    image = image.convert("RGB")
    pixels = list(image.getdata())  # type: ignore
    pixel_len = len(pixels)
    message_len = len(message)

    if message_len > len(pixels) * 3:
        raise ValueError("Image is too small for the message.")

    new_pixels = list()
    message_index = 0
    for pixel in pixels:
        if message_index >= message_len:
            new_pixels.append(pixel)
            continue
        r, g, b = pixel
        if message_index < message_len:
            r = (r & ~1) | int(message[message_index])
            message_index += 1
        if message_index < message_len:
            g = (g & ~1) | int(message[message_index])
            message_index += 1
        if message_index < message_len:
            b = (b & ~1) | int(message[message_index])
            message_index += 1
        new_pixels.append((r, g, b))

    image.putdata(new_pixels)
    image.save(save_name)
    image.close()
    DONE = True


def decode(img_path, delimiter: str = "11111110"):
    global DONE
    image = Image.open(img_path)
    image = image.convert("RGB")
    pixels = list(image.getdata())  # type: ignore
    pixel_len = len(pixels)
    binary_message = ""

    for pixel in pixels:
        r, g, b = pixel
        binary_message += str(r & 1)
        binary_message += str(g & 1)
        binary_message += str(b & 1)

    binary_chars = [binary_message[i : i + 8] for i in range(0, len(binary_message), 8)]
    message = ""
    for binary_char in binary_chars:
        if binary_char == delimiter:
            break
        message += chr(int(binary_char, 2))
    image.close()

    DONE = True
    return message


class ED:
    def __init__(self, file_path: str, delimiter: str = "11111110"):
        if not os.path.isfile(file_path):
            raise ValueError("file does not exist.")
        self.file_path = file_path
        file_split = [value[::-1] for value in self.file_path[::-1].split(".", 1)]
        self.file_extension = file_split[0]
        self.file_name = file_split[1]
        self.delimiter = delimiter

    def __error(self, error_type, message: str = ""):
        errors = {
            ValueError: "There is a error.",
        }
        raise error_type(message or errors[error_type])

    def __file_type(self, path: str = ""):
        file_type, enocding = mimetypes.guess_type(self.file_path or path)
        file_type, file_extension = file_type.split("/")  # type: ignore
        return {
            "file_type": file_type,
            "file_extension": file_extension,
            "encoding": enocding,
        }

    def __is_type(self, file_type, file_path: str | None = None):
        if file_path:
            if not os.path.isfile(file_path):
                self.__error(ValueError, "File does not exist.")
        else:
            file_path = self.file_path
        if self.__file_type(file_path)["file_type"] == file_type:
            return True
        else:
            self.__error(ValueError, "Not a image file.")

    def __to_bin(self, string, format_to: str = "08b", delimiter: str = "11111110"):
        string = "".join([format(ord(chr), format_to) for chr in string]) + (
            delimiter or self.delimiter
        )
        return string

    def encode_in_image(
        self,
        message: str | None = None,
        message_file: str | None = None,
        encoded_file_name: str | None = None,
    ):
        self.__is_type("image")
        if message_file:
            if not os.path.isfile(message_file):
                with open(message_file, "r") as file:
                    message = file.read()
        elif message:
            pass
        else:
            self.__error(ValueError, "No message.")
        message = self.__to_bin(message)
        print(message)

    def decode_from_image(self, img_path):
        self.__is_type("image", file_path=img_path)

    def encode_in_audio(self): ...
    def decode_from_audio(self): ...
    def encode_in_video(self): ...
    def decode_from_video(self): ...


struc = {
    "-e": {
        "alias": ["--encode"],
        "input": True,
        "input_type": {
            "datatype": str,
            "description": "path-to-image",
            "parameter": "img_path",
        },
        "function": encode,
        "decorator_function": decor(),
        "default_args": {
            "delimiter": "11111110",
        },
        "next": {
            "-m": {
                "alias": ["--message"],
                "input": True,
                "input_type": {
                    "datatype": str,
                    "description": "message-to-encode",
                    "parameter": "text",
                },
                "function": encode,
                "next": None,
            },
            "-f": {
                "alias": ["--file"],
                "input": True,
                "input_type": {
                    "datatype": str,
                    "description": "path-to-file",
                    "parameter": "file_path",
                },
                "function": encode,
                "next": None,
            },
        },
    },
    "-d": {
        "alias": ["--decode"],
        "input": True,
        "input_type": {
            "datatype": str,
            "description": "path-to-image",
            "parameter": "img_path",
        },
        "function": decode,
        "decorator_function": decor(),
        "next": {
            "-o": {
                "alias": ["--output"],
                "input": True,
                "input_type": {
                    "datatype": str,
                    "description": "output-file-name",
                    "parameter": "file_path",
                },
                "next": None,
            }
        },
    },
    "all": {
        "-h": {
            "alias": ["--help"],
            "input": False,
            "function": help,
            "default_args": {
                "request": Tcam,
            },
            "next": None,
        },
    },
}

commands = Tcam(struc).run_config()
print(commands)


# x = ED("./anime-cat-girl-ai-art-4k-wallpaper-uhdpaper.com-726@1@l.jpg")
# x.encode_in_image(message="Hello, World!!!")
